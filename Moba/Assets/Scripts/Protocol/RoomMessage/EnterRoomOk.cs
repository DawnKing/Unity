// Generated by proto_to_csharp.py. DO NOT EDIT!
using System.IO;

using GameProtocol.BulkDataType;
namespace GameProtocol.RoomMessage
{
    // MSGTYPE_DECLARE_ASSIGN(MSG_ENTER_ROOM_OK, 1450),
    // 成功进入房间，通知房间信息
    public sealed class EnterRoomOk : IProtocol
    {
        public const short MsgType = MessageType.MSG_ENTER_ROOM_OK;
        public short GetMsgType { get { return MsgType; } }
        public uint RoomId;// 房间id
        public uint CreateId;// 创建者id
        public uint MapId;// 地图模板id
        public uint Max;// 最大人数
        public uint Min;// 最少人数
        public uint Password;// 房间密码
        public string szName;// 房间名
        public byte state;// 房间状态 enum ROOM_STATE_TYPE
        public byte Type;// 房间类型 enum ROOM_TYPE
        public uint mode;// 房间模式 enum BATTLE_MODE 普通匹配，为匹配模式选择
        public byte BanRobot;// 是否禁止机器人
        public uint[] readyVec;// 完成准备的成员列表
        public uint[] battleVec;// 战斗中的成员列表
        public CHAR_BRIEF[] charVec;// 成员数据
        
        public static void Send(uint roomId, uint createId, uint mapId, uint max, uint min, uint password, string szName, byte state, byte type, uint mode, byte banRobot, uint[] readyVec, uint[] battleVec, CHAR_BRIEF[] charVec, object className)
        {
            var packet = new EnterRoomOk
            {
                RoomId = roomId,
                CreateId = createId,
                MapId = mapId,
                Max = max,
                Min = min,
                Password = password,
                szName = szName,
                state = state,
                Type = type,
                mode = mode,
                BanRobot = banRobot,
                readyVec = readyVec,
                battleVec = battleVec,
                charVec = charVec
            };
            NetMessage.Send(packet.BuildPacket(), className);
        }
        
        public byte[] BuildPacket()
        {
            var buffer = ProtocolBuffer.Writer;
            buffer.Write(MsgType);
            buffer.Write(ProtocolBuffer.Zero);
            WriteToStream(buffer);
            return ProtocolBuffer.CacheStream.ToArray();
        }
        
        public void ReadFromStream(BinaryReader reader)
        {
            RoomId = reader.ReadUInt32();
            CreateId = reader.ReadUInt32();
            MapId = reader.ReadUInt32();
            Max = reader.ReadUInt32();
            Min = reader.ReadUInt32();
            Password = reader.ReadUInt32();
            szName = reader.ReadString();
            state = reader.ReadByte();
            Type = reader.ReadByte();
            mode = reader.ReadUInt32();
            BanRobot = reader.ReadByte();
            var length12 = reader.ReadUInt16();
            readyVec = new uint[length12];
            for (var i12 = 0; i12 < length12; i12++)
            {
                readyVec[i12] = reader.ReadUInt32();
            }
            var length13 = reader.ReadUInt16();
            battleVec = new uint[length13];
            for (var i13 = 0; i13 < length13; i13++)
            {
                battleVec[i13] = reader.ReadUInt32();
            }
            var length14 = reader.ReadUInt16();
            charVec = new CHAR_BRIEF[length14];
            for (var i14 = 0; i14 < length14; i14++)
            {
                charVec[i14] = new CHAR_BRIEF();
                charVec[i14].ReadFromStream(reader);
            }
        }
        
        public void WriteToStream(BinaryWriter writer)
        {
            writer.Write(RoomId);
            writer.Write(CreateId);
            writer.Write(MapId);
            writer.Write(Max);
            writer.Write(Min);
            writer.Write(Password);
            writer.Write(szName);
            writer.Write(state);
            writer.Write(Type);
            writer.Write(mode);
            writer.Write(BanRobot);
            ushort count12 = (ushort)(readyVec == null ? 0 : readyVec.Length);
            writer.Write(count12);
            for(var i12 = 0; i12 < count12; i12++)
            {
                writer.Write(readyVec[i12]);
            }
            ushort count13 = (ushort)(battleVec == null ? 0 : battleVec.Length);
            writer.Write(count13);
            for(var i13 = 0; i13 < count13; i13++)
            {
                writer.Write(battleVec[i13]);
            }
            ushort count14 = (ushort)(charVec == null ? 0 : charVec.Length);
            writer.Write(count14);
            for(var i14 = 0; i14 < count14; i14++)
            {
                charVec[i14].WriteToStream(writer);
            }
        }
    }
}
