// Generated by proto_to_csharp.py. DO NOT EDIT!
using System.IO;

using GameProtocol.BulkDataType;
namespace GameProtocol.TestMessage
{
    // MSGTYPE_DECLARE(MSG_TEST_FULL_DATATYPE),
    //测试 协议所支持的各种类型
    public sealed class TestFullDataTypes : IProtocol
    {
        public const short MsgType = MessageType.MSG_TEST_FULL_DATATYPE;
        public short GetMsgType { get { return MsgType; } }
        public byte m_uint8;
        public ushort m_uint16;
        public uint m_uint32;
        public ulong m_uint64;
        public byte m_int8;
        public short m_int16;
        public int m_int32;
        public long m_int64;
        public double m_float32;
        public string m_string;
        public TestInfo info;
        public TestInfo[] infos;
        public uint[] ints;
        public LimitInfo limit;
        
        public static void Send(byte m_uint8, ushort m_uint16, uint m_uint32, ulong m_uint64, byte m_int8, short m_int16, int m_int32, long m_int64, double m_float32, string m_string, TestInfo info, TestInfo[] infos, uint[] ints, LimitInfo limit, object className)
        {
            var packet = new TestFullDataTypes
            {
                m_uint8 = m_uint8,
                m_uint16 = m_uint16,
                m_uint32 = m_uint32,
                m_uint64 = m_uint64,
                m_int8 = m_int8,
                m_int16 = m_int16,
                m_int32 = m_int32,
                m_int64 = m_int64,
                m_float32 = m_float32,
                m_string = m_string,
                info = info,
                infos = infos,
                ints = ints,
                limit = limit
            };
            NetMessage.Send(packet.BuildPacket(), className);
        }
        
        public byte[] BuildPacket()
        {
            var buffer = ProtocolBuffer.Writer;
            buffer.Write(MsgType);
            buffer.Write(ProtocolBuffer.Zero);
            WriteToStream(buffer);
            return ProtocolBuffer.CacheStream.ToArray();
        }
        
        public void ReadFromStream(BinaryReader reader)
        {
            m_uint8 = reader.ReadByte();
            m_uint16 = reader.ReadUInt16();
            m_uint32 = reader.ReadUInt32();
            m_uint64 = reader.ReadUInt64();
            m_int8 = reader.ReadByte();
            m_int16 = reader.ReadInt16();
            m_int32 = reader.ReadInt32();
            m_int64 = reader.ReadInt64();
            m_float32 = reader.ReadSingle();
            m_string = reader.ReadString();
            info = new TestInfo();
            info.ReadFromStream(reader);
            var length12 = reader.ReadUInt16();
            infos = new TestInfo[length12];
            for (var i12 = 0; i12 < length12; i12++)
            {
                infos[i12] = new TestInfo();
                infos[i12].ReadFromStream(reader);
            }
            var length13 = reader.ReadUInt16();
            ints = new uint[length13];
            for (var i13 = 0; i13 < length13; i13++)
            {
                ints[i13] = reader.ReadUInt32();
            }
            limit = new LimitInfo();
            limit.ReadFromStream(reader);
        }
        
        public void WriteToStream(BinaryWriter writer)
        {
            writer.Write(m_uint8);
            writer.Write(m_uint16);
            writer.Write(m_uint32);
            writer.Write(m_uint64);
            writer.Write(m_int8);
            writer.Write(m_int16);
            writer.Write(m_int32);
            writer.Write(m_int64);
            writer.Write(m_float32);
            writer.Write(m_string);
            info.WriteToStream(writer);
            ushort count12 = (ushort)(infos == null ? 0 : infos.Length);
            writer.Write(count12);
            for(var i12 = 0; i12 < count12; i12++)
            {
                infos[i12].WriteToStream(writer);
            }
            ushort count13 = (ushort)(ints == null ? 0 : ints.Length);
            writer.Write(count13);
            for(var i13 = 0; i13 < count13; i13++)
            {
                writer.Write(ints[i13]);
            }
            limit.WriteToStream(writer);
        }
    }
}
