#!/usr/bin/python2.7
# coding: utf-8

import time
import os
import sys
import re
from printer import Printer
from util import DumpDirExt, RunProfile
from proto_parser import ProtoParser
from proto_handler import FindCachedProtoTypes
from const import FIXSTR_TAG

class IntType:
    def GetStoreType(self):
        return "int"
    def GetWriteMethod(self):
        return "%{stream_name}s.WriteInt(%{var_name}s)"

g_type_dict = {
               "bool": ["bool", "ReadBoolean", "Write", "true"],
               "char": ["char", "ReadChar", "Write", "0"],
               "CHAR": ["char", "ReadChar", "Write", "0"],
               "byte": ["byte", "ReadByte", "Write", "0"],
               "BYTE": ["byte", "ReadByte", "Write", "0"],
               "Int8": ["sbyte", "ReadSByte", "Write", "0"],
               "UINT8": ["byte", "ReadByte", "Write", "0"],
               "short": ["short", "ReadInt16", "Write", "0"],
               "Int16": ["short", "ReadInt16", "Write", "0"],
               "INT16": ["short", "ReadInt16", "Write", "0"],
               "UINT16":["ushort", "ReadUInt16", "Write", "0"],
               "int": ["int", "ReadInt32", "Write", "0"],
               "INT": ["int", "ReadInt32", "Write", "0"],
               "Int32": ["int", "ReadInt32", "Write", "0"],
               "INT32": ["int", "ReadInt32", "Write", "0"],
               "uint": ["uint", "ReadUInt32", "Write", "0"],
               "UINT32":["uint", "ReadUInt32", "Write", "0"],
               "float":["float", "ReadSingle", "Write", "0"],
               "FLOAT":["double", "ReadSingle", "Write", "0"],
               "Int64": ["long", "ReadInt64", "Write", "0"],
               "INT64": ["long", "ReadInt64", "Write", "0"],
               "UINT64":["ulong", "ReadUInt64", "Write", "0"],
               "string": ["string", "ReadString", "Write", ""],
               "String": ["string", "ReadString", "Write", '""'],
               "ZGID": ["ulong", "ReadUInt64", "Write", "0"],
}

class CSharpGenerator:
    """
    This class will transmit protocol-define file to  Actionscript source code.
    The Rule to Generate ActionScript:
    1. Every proto-file will be a package.
    2. Every message will be an action script class.
    3. Every enum will be a enum class.    
    4. We need do some stastics.
    """
    def __init__(self, outdir):
        self.outdir = outdir
        self.printerDict = {}
        self.enum_set = set()
        self.class_set = set()
        self.package_set = set()
        self.node_stack = []
        self.cached_comments = []
        self.printer = None
        self.param_str = ""     # 函数参数列表，如string name, string passwd, string adult
    
    def OnAddNode(self, node):
        if node.token == "package":
            self.package_set.add(node)
        elif node.token == "enum_stmt":
            self.enum_set.add(node)
        elif node.token == "message_stmt":
            #print "add class node %s" % node.value
            self.class_set.add(node)
    
    def GenerateMessageDef(self, node):
        printer = self.FindPrinter(node)     
        printer.AppendLine("// Generated by proto_to_csharp.py. DO NOT EDIT!")
        printer.AppendLine("using System.IO;")    
        printer.AppendLine("")
        printer.AppendLine("namespace GameProtocol.%s" % self.package_name)
        printer.AppendLine("{")
        printer.IncIndent()
        for c in self.cached_comments:
            printer.AppendLine(c)
        self.cached_comments = []
        if self.NeedConstructor(node):
            printer.AppendLine("public sealed class %s : IProtocol" % node.value)
        else:
            printer.AppendLine("public sealed class %s" % node.value)
        printer.AppendLine("{")
        printer.IncIndent()       
        self.printer = printer
        self.param_str = ""

    def GenerateStructure(self, node):
        self.printer.AppendLine("")
        # self.printer.AppendLine("public %s()" % node.value)
        # self.printer.AppendLine("{")
        # self.printer.AppendLine("}")
        # self.printer.AppendLine("")
        # self.printer.AppendLine("public %s(BinaryReader reader = null)" % node.value)
        # self.printer.AppendLine("{")
        # self.printer.IncIndent()
        # self.printer.AppendLine("if (reader != null)")
        # self.printer.IncIndent()
        # self.printer.AppendLine("ReadFromStream(reader);")
        # self.printer.DecIndent()
        # self.printer.DecIndent()
        # self.printer.AppendLine("}")
        # self.printer.AppendLine("")

    def GenerateSend(self, node):
        function_str = ""
        memberCount = 0
        for field in node.childs:
            if field.token != "field_stmt":
                continue
            memberCount += 1
            field_lable, field_type, field_name, field_index = field.value
            field_name = self.FormatFieldName(field_name)
            param_name = self.FormatParamsName(field_name)
            function_str += ",\n" if function_str != "" else ""
            function_str += "%s = %s" % (field_name, param_name)

        self.printer.AppendLine("public static void Send(%sobject className)" % self.param_str)
        self.printer.AppendLine("{")
        self.printer.IncIndent()
        if len(function_str) > 0:
            self.printer.AppendLine("var packet = new %s" % (node.value))
            self.printer.AppendLine("{")
            self.printer.IncIndent()
            self.printer.AppendLine(function_str)
            self.printer.DecIndent()
            self.printer.AppendLine("};")
        else:
            self.printer.AppendLine("var packet = new %s();" % (node.value))
        self.printer.AppendLine("NetMessage.Send(packet.BuildPacket(), className);")
        self.printer.DecIndent()
        self.printer.AppendLine("}")
        self.printer.AppendLine("")

    def GenerateSync(self, node):
        self.printer.AppendLine("public static readonly %s CacheData = new %s();" % (node.value, node.value))
        self.printer.AppendLine("public static %s Sync(BinaryReader reader)" % (node.value))
        self.printer.AppendLine("{")
        self.printer.IncIndent()
        self.printer.AppendLine("CacheData.ReadFromStream(reader);")
        self.printer.AppendLine("return CacheData;")
        self.printer.DecIndent()
        self.printer.AppendLine("}")
        self.printer.AppendLine("")

    def GenerateReadFromStream(self, node):
        self.printer.AppendLine("public void ReadFromStream(BinaryReader reader)")
        self.printer.AppendLine("{")
        self.printer.IncIndent()
        memberCount = 0
        for field in node.childs:
            if field.token != "field_stmt":
                continue
            memberCount += 1
            field_lable, field_type, field_name, field_index = field.value
            field_name = self.FormatFieldName(field_name)
            if field_lable == "required":
                self.printer.AppendLine(self.DetermineReadMethod(field_type, field_name))
            elif field_lable == "repeated":
                self.printer.AppendLine("var length%d = reader.ReadUInt16();" % memberCount)
                self.printer.AppendLine("%s = new %s[length%d];" % (field_name, self.GetAsType(field_type), memberCount))
                self.printer.AppendLine("for (var i%d = 0; i%d < length%d; i%d++)" % (memberCount, memberCount, memberCount, memberCount))
                self.printer.AppendLine("{")
                self.printer.IncIndent()
                self.printer.AppendLine(self.DetermineReadMethod(field_type, "%s[i%d]" % (field_name, memberCount)))
                self.printer.DecIndent()
                self.printer.AppendLine("}")
                                           
        self.printer.DecIndent()
        self.printer.AppendLine("}\n")         

    def DetermineWriteMethod(self, field_type, field_name):
        if self.IsEnumType(field_type):
            return "writer.Write(%s);" % field_name
        elif self.IsClassType(field_type):
            return "%s.WriteToStream(writer);" % field_name
        elif g_type_dict.has_key(field_type):
            return "writer.%s(%s);" % (g_type_dict[field_type][2], field_name)
        elif field_type.startswith(FIXSTR_TAG):
            return "writer.Write(%s);" % (field_name)
       
        raise SyntaxError, field_type

    def DetermineReadMethod(self, field_type, field_name):
        if self.IsEnumType(field_type):
            return "%s = reader.ReadInt32();" % field_name
        elif self.IsClassType(field_type):
            return "%s = new %s();\n%s.ReadFromStream(reader);" % (field_name, field_type, field_name) 
        elif g_type_dict.has_key(field_type):
            return "%s = reader.%s();" % (field_name, g_type_dict[field_type][1])
        elif field_type.startswith(FIXSTR_TAG):
            return "%s = reader.ReadString();" % (field_name)
        raise SyntaxError, field_type

    def GenerateWriteToStream(self, node):
        self.printer.AppendLine("public void WriteToStream(BinaryWriter writer)")
        self.printer.AppendLine("{")
        self.printer.IncIndent()
        memberCount = 0
        for field in node.childs:
            if field.token != "field_stmt":
                continue
            memberCount += 1
            field_lable, field_type, field_name, field_index = field.value
            field_name = self.FormatFieldName(field_name)
            if field_lable == "required":
                self.printer.AppendLine(self.DetermineWriteMethod(field_type, field_name))
            elif field_lable == "repeated":
                self.printer.AppendLine("ushort count%d = (ushort)(%s == null ? 0 : %s.Length);" % (memberCount, field_name, field_name))
                self.printer.AppendLine("writer.Write(count%d);" % (memberCount))
                self.printer.AppendLine("for(var i%d = 0; i%d < count%d; i%d++)" % (memberCount, memberCount, memberCount, memberCount))
                self.printer.AppendLine("{")
                self.printer.IncIndent()
                self.printer.AppendLine(self.DetermineWriteMethod(field_type, "%s[i%d]" % (field_name, memberCount)))
                self.printer.DecIndent()
                self.printer.AppendLine("}")                                          
        self.printer.DecIndent()        
        self.printer.AppendLine("}")
    
    def NeedConstructor(self, node):
        for child in node.childs:
            if child.token == "enum_stmt":
                if child.childs[0].value[0] == "THIS_MSG_TYPE":
                    return True
        return False
    
    def GenerateBuildPacket(self):
        self.printer.AppendLine("public byte[] BuildPacket()")        
        self.printer.AppendLine("{")
        self.printer.IncIndent()
        self.printer.AppendLine("var buffer = ProtocolBuffer.Writer;")
        self.printer.AppendLine("buffer.Write(MsgType);");
        self.printer.AppendLine("buffer.Write(ProtocolBuffer.Zero);");
        self.printer.AppendLine("WriteToStream(buffer);")
        self.printer.AppendLine("return ProtocolBuffer.CacheStream.ToArray();")
        self.printer.DecIndent()
        self.printer.AppendLine("}\n")
    
        
    def GenerateMessageDefEnd(self, node):
        if self.NeedConstructor(node):
            self.GenerateStructure(node)
            self.GenerateSend(node)
            # self.GenerateSync(node)
            self.GenerateBuildPacket()
        self.GenerateReadFromStream(node)
        self.GenerateWriteToStream(node)
        printer = self.FindPrinter(node)
        printer.DecIndent()
        printer.AppendLine("}")
        printer.DecIndent()
        printer.AppendLine("}")
    
    def IsEnumType(self, type_name):
        for enum in self.enum_set:
            #print "enum:", enum
            if enum.value == type_name:
                return True
        return False
    
    def IsClassType(self, type_name):
        for class_node in self.class_set:
            #print "class:", class_node.value
            if class_node.value == type_name:
                return True
        return False
        
    def GetAsType(self, type_name):
        if g_type_dict.has_key(type_name):
            return g_type_dict[type_name][0]
        
        if self.IsEnumType(type_name):
            return "int"
        
        if self.IsClassType(type_name):
            return type_name
        
        if type_name.startswith(FIXSTR_TAG):
            return "string"
        
        raise SyntaxError, type_name + self.printer.filename
    
    def IsValidType(self, field_type):
        return True
    
    def FindPackageName(self, node):
        while node.parent != None:
            node = node.parent
            if hasattr(node, "filename"):
                return os.path.basename(os.path.splitext(node.filename)[0])
        return None        
    
    def DoNeedImport(self, type_name):
        for class_node in self.class_set:
            #print "class:", class_node.value
            if class_node.value == type_name:
                name =  self.FindPackageName(class_node)
                if name == self.package_name:
                    return None
                else:
                    return name
        return None
    
    def ImportFile(self, filename):
        import_file_path = os.path.join(self.input_dir, filename+".proto")
        enum_set, class_set = FindCachedProtoTypes(import_file_path)
        self.enum_set.update(enum_set)
        self.class_set.update(class_set)
        #print self.class_set

    def FormatFieldName(self, field_name):
        result = field_name.replace("m_b", "")
        result = result.replace("m_u", "")
        result = result.replace("m_n", "")
        result = result.replace("m_i", "")
        # 格式化后首字符为数字
        if re.search("\d", result):
            return field_name
        # 格式化后首字母不为大写，则原来是单词
        if result[0].islower():
            result = field_name
        #result = result.title()
        result = result.replace("m_", "")
        #result = result.replace("_", "")
        if g_type_dict.has_key(result):
            return field_name
        return result

    def FormatParamsName(self, s):
        if len(s) == 0:
            result = s
        else:
            result = s[0].lower() + s[1:]

        if g_type_dict.has_key(result):
            result += "_"
        return result
        
    def GenerateField(self, node):
        field_lable = node.value[0]
        field_type = node.value[1]
        field_name = node.value[2]
        field_name = self.FormatFieldName(field_name)
        func_param_name = self.FormatParamsName(field_name)

        if not self.IsValidType(field_type):
            print "TYPE: %s is not declared" % field_type
        else:
            import_package = self.DoNeedImport(field_type)
            if import_package != None:
                using = "using GameProtocol.%s;" % (import_package)
                if self.printer.lines.count(using) == 0:
                    self.printer.lines.insert(3, using)            
        
        field_type = self.GetAsType(field_type)

        # 生成函数参数列表，如string name, string passwd, string adult
        if field_lable != "repeated":
            self.printer.AppendLine("public %s %s;" % (field_type, field_name))
            self.param_str += "%s %s, " % (field_type, func_param_name)
        else:
            self.printer.AppendLine("public %s[] %s;" % (field_type, field_name))
            self.param_str += "%s[] %s, " % (field_type, func_param_name)
        
    def FindPrinter(self, node):
        filename = node.value + ".cs"
        file_full_path = "%s/%s/%s" % (self.outdir, self.package_name, filename)
        if not self.printerDict.has_key(file_full_path): 
            printer = Printer(file_full_path)
            self.printerDict[file_full_path] = printer
            return printer
        else:
            return self.printerDict[file_full_path]

    def GenerateEnumStmt(self, node):
        if node.parent.token == "message_stmt":
            pass
        else:
            printer = self.FindPrinter(node)
            printer.AppendLine("// Generated by proto_to_csharp.py. DO NOT EDIT!")
            printer.AppendLine("namespace GameProtocol.%s" % self.package_name)
            printer.AppendLine("{")
            printer.IncIndent()
            printer.AppendLine("public sealed class %s" % node.value)
            printer.AppendLine("{")
            printer.IncIndent()
            self.printer = printer
            
    def GenerateEnumStmtEnd(self, node):
        if node.parent.token == "message_stmt":
            pass
        else:
            printer = self.FindPrinter(node)
            printer.DecIndent()
            printer.AppendLine("}")
            printer.DecIndent()            
            printer.AppendLine("}")           
        
    def GenerateEnumFieldStmt(self, node):
        if node.value[0] == "THIS_MSG_TYPE":
            self.printer.AppendLine("public const short MsgType = MessageType.%s;" % (node.value[1]))
            self.printer.AppendLine("public short GetMsgType { get { return MsgType; } }")
        else:
            self.printer.AppendLine("public const int %s = %s;" % (node.value[0], node.value[1]))
    
    def BeginNode(self, node):
        self.node_stack.append(node.token)
        if node.token == "import_stmt":
            self.ImportFile(node.value)
        if node.token == "message_stmt":
            self.GenerateMessageDef(node)
        elif node.token == "field_stmt":
            self.GenerateField(node)
        elif node.token == "enum_stmt":
            self.GenerateEnumStmt(node)
        elif node.token == "enum_field_stmt":
            self.GenerateEnumFieldStmt(node)
        elif node.token == "comment":
            text = node.value.decode('gbk', 'ignore').encode('utf8')
            text = text.replace("///<", "//")
            if len(self.node_stack) == 0 or \
               self.printer == None or \
               "message_stmt" not in self.node_stack:
                self.cached_comments.append(text)
            else:
                self.printer.AppendSameLine(text)
                return ""
            if "enum_stmt" in self.node_stack:
                self.printer.AppendSameLine(text)
        
        return ""
    
    def EndNode(self, node):        
        if node.token == "message_stmt":
            self.GenerateMessageDefEnd(node)
        elif node.token == "enum_stmt":
            self.GenerateEnumStmtEnd(node)
        self.node_stack.pop()        
        return ""
    
    def Generate(self, tree, input_file_path):
        self.input_dir = os.path.dirname(input_file_path)
        self.package_name = os.path.basename(os.path.splitext(input_file_path)[0])
        tree.Apply(self)
        for printer in self.printerDict.values():
            printer.Flush()
    
def Main():
    input_path = "E:\MobaGame\Moba\Tools\Protocol\input"
    output_path = "E:\MobaGame\Moba\Tools\Protocol\output"
    if len(sys.argv) >= 3:    
        input_path = sys.argv[1] 
        output_path = sys.argv[2]    
    
    def DumpFile(filename, targetDir):
        cpp_generator = CSharpGenerator(targetDir)
        parser = ProtoParser()
        parser.RegisterGenerator(cpp_generator)
        print "parse <" + filename + ">"
        parser.ParseFile(os.path.abspath(filename))                
        cpp_generator.Generate(parser.tree, os.path.abspath(filename))
    
    start = time.time()
    print "Begin "
    DumpDirExt(".proto", input_path, output_path, DumpFile)
    print "END. (used %f)." % (time.time() - start)

if __name__ == "__main__":
    #RunProfile(Main)
    Main()
